# -*- coding: utf-8 -*-
"""AAAЭто мой на пробу биткоин "Копия блокнота "BTC_lstm.ipynb""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qH57rFPtXtUsvMAIVPZAzlZSpOCkDNkN

# Пояснительная записка.
### Бизнес-задача (проблематика проекта)
Bitcoin - это криптовалюта, которая находится вне контроля центральных банков и государств. Ее цена определяется исключительно спросом и предложением на рынке. Цена на биткоин может значительно колебаться из-за изменений в мировой экономике, изменений в правительственной политике, а также из-за поведения "жадных" и паникующих инвесторов. Прогнозирование цены на биткоин может помочь инвесторам принимать обоснованные решения о покупке и продаже биткоина.
Бизнес-задача проекта заключается в создании модели машинного обучения для прогнозирования цен на биткоин на основе исторических данных. Эта модель может быть использована для принятия инвестиционных решений, торговли и других стратегических решений, связанных с криптовалютой.

### Ход разработки данного проекта состоит из следующих этапов:

1. Сбор данных. В данном проекте используются исторические данные о ценах на биткоин.

2. Предобработка данных. Данные очищаются от выбросов, пропущенных значений и других ошибок.

3. Анализ данных. В данном проекте используется анализ временных рядов для определения закономерностей в данных.

4. Разработка модели. В данном проекте используется модель LSTM для прогнозирования цен на биткоин.

5. Обучение модели. Модель обучается на исторических данных.

6. Тестирование модели. Модель тестируется на данных, которых еще не было в обучающей выборке.

7. Оценка результатов. Результаты модели сравниваются с реальными данными.

8. Деплой модели. Модель разворачивается в продакшн-среде и используется для прогнозирования цен на биткоин в реальном времени.

### Для этого проекта были применены следующие методы и инструменты:

1. Python - используется для разработки модели машинного обучения.

2. Библиотека Pandas. Эта библиотека используется для работы с данными.

3. Библиотека NumPy. Эта библиотека используется для работы с массивами данных.

4. Библиотека Matplotlib. Эта библиотека используется для визуализации данных.

5. Библиотека Keras. Эта библиотека используется для разработки модели LSTM.

6. Google Colab. Этот инструмент используется для запуска кода на удаленных серверах (в том числе для создания и отладки кода).

7. GitHub. Этот инструмент используется для хранения и управления версиями проекта.

## Сбор, предобработка и анализ данных

Для обучения модели машинного обучения нам понадобятся данные о цене биткоина. В данном проекте применяется датасет, взятый с сайта https://kaggle.com с данными об изменениях цен за биткоин (BTC) относительно доллара (USD) за 2014-2022 годы.
"""

# Устанавливаем необходимые библиотеки

import numpy as np # библиотека для работы с многомерными массивами данных
import pandas as pd # библиотека для работы с данными
from matplotlib import pyplot as plt # библиотека для визуализации данных
from keras.models import Sequential # модуль библиотеки Keras для создания последовательных моделей нейронных сетей
from keras.layers import Dense # модуль библиотеки Keras, предоставляет различные типы слоев
from keras.layers import LSTM # модуль библиотеки Keras, предоставляет различные типы слоев
from sklearn.preprocessing import MinMaxScaler # класс из библиотеки Scikit-learn для масштабирования данных на заданный диапазон

# Подключаем google drive

from google.colab import drive
drive.mount('/content/drive')

# Устанавливаем и импортируем библиотеку для обработки больших объемов данных

!pip install datatable
import datatable as dt

"""### Сбор данных. Загружаем csv-файл"""

# Импортируем данные, загружаем датасет

dir_data= "/content/drive/MyDrive/МЭО/Итоговый проект/BTC-USD.csv"
dt_df = dt.fread(dir_data)
pd_df = dt_df.to_pandas()
pd_df.head() # выводим первые 5 строк таблицы

pd_df.tail() # выводим последние 5 строк таблицы

"""### Предобработка данных."""

# Используем библиотеку pandas для обработки данных временных рядов в файле CSV

pd_df['Date'] = pd.to_datetime(pd_df['Date'],unit='s').dt.date # преобразуем даты
group = pd_df.groupby('Date') # группируем данные по дате
Real_Price = group['High'].mean() # вычислим среднее значение цены
pd_df.drop('Adj Close', axis=1, inplace=True) # удалим столбцы, которые не несут информации для нашей задачи
pd_df.drop('Volume', axis=1, inplace=True)
pd_df = pd_df.drop_duplicates() # удалим дубликаты, если они есть
pd_df = pd_df.dropna() # удалим пропущенные значения, если они есть

pd_df.head()

"""Анализ выбросов"""

plt.hist(pd_df['High'], bins=50) # построим гистограмму распределения цен на биткоин
plt.show()

"""На гистограмме мы видим высокую частоту встречающихся значений в диапазоне цен до 1500 USD за BTC. Чтобы проанализировать эти значения на предмет выбросов, мы обратились к статистическим данным. Оказалось, что диапазон цен на биткоин в период с 2014 до 2017 года как раз приходился на данный диапазон, примерно от 200 до 1500 USD за BTC. Из чего можно сделать вывод, что эти данные не являются выбросом. На всякий случай удалим экстримальные значения цен, которые не попадают в ценовой диапазон за данные периоды времени."""

pd_df = pd_df[(pd_df['High'] > 200) & (pd_df['High'] < 80000)] # обработаем выбросы в данных, если таковые имеются

"""Разбиваем данные на обучающую и тестовую выборки."""

# Инициализируем необходимые переменные, задаем значения

prediction_days = 30 # количество дней для прогноза
nof_units = 4 # количество нейронов в скрытом слое LSTM модели

# разбиваем Real_Price на два датафрейма "df_train" и "df_test",
# которые будут использоваться для обучения и тестирования модели предсказания временных рядов

df_train= Real_Price[:len(Real_Price)-prediction_days] # данные до даты, начиная с которой мы будем делать прогноз
df_test= Real_Price[len(Real_Price)-prediction_days:] # данные для проверки точности прогнозирования модели

# Подготавливаем данные для обучения модели LSTM

training_set = df_train.values # конвертируем датафрейм "df_train" в массив numpy
training_set = np.reshape(training_set, (len(training_set), 1)) # изменяем форму массива для нормализации данных
sc = MinMaxScaler()
training_set = sc.fit_transform(training_set)
# создаем два массива numpy "X_train" и "y_train", которые будут использоваться для обучения модели.
# это необходимо, чтобы модель могла предсказывать следующее значение временного ряда на основе предыдущего.
X_train = training_set[0:len(training_set)-1] # содержит значения цен за все дни, кроме последнего
y_train = training_set[1:len(training_set)] # содержит значения цен за все дни, кроме первого
X_train = np.reshape(X_train, (len(X_train), 1, 1)) # изменяем форму массива "X_train" в трехмерный массив для использования в LSTM модели

"""## Моделирование.
Для осуществления нашей задачи мы выбрали модель LSTM, потому что цены на криптовалюты обычно имеют временную зависимость и тенденции, которые могут быть захвачены с помощью анализа временных рядов. 

LSTM (Long Short-Term Memory) - это вид рекуррентной нейронной сети, которая хорошо работает для анализа последовательных данных, особенно временных рядов. LSTM способна обрабатывать длинные последовательности и запоминать информацию на длительный период времени, что позволяет ей более точно прогнозировать будущие значения.
"""

# Инициализируем функцию создания модели

def create_model(nunits):
    regressor = Sequential() # создаем объект модели
    regressor.add(LSTM(units = nunits, activation = 'sigmoid', input_shape= (None, 1))) # добавляем входной слой LSTM
    regressor.add(Dense(units = 1)) # добавляем входной слой Dense
    regressor.compile(optimizer = 'adam', loss = 'mean_squared_error') # компилируем модель с помощью метода compile
    return regressor # возвращаем объект модели

# Создаем и обучаем модель LSTM на основе данных "X_train" и "y_train"

regressor = create_model(nunits = nof_units)
regressor.fit(X_train, y_train, batch_size = 5, epochs = 100)

# Используем обученную модель LSTM для предсказания значений цен на новых данных, содержащихся в датафрейме "df_test"

test_set = df_test.values # конвертируем датафрейм в массив numpy
inputs = np.reshape(test_set, (len(test_set), 1)) # изменяем форму массива, чтобы его можно было нормализовать
inputs = sc.transform(inputs) # нормализуем данные
inputs = np.reshape(inputs, (len(inputs), 1, 1)) # изменяем форму массива в трехмерный массив для использования в LSTM модели
predicted_BTC_price = regressor.predict(inputs) # вызываем метод "predict" на объекте модели "regressor" для предсказания цен на новых данных "inputs"
predicted_BTC_price = sc.inverse_transform(predicted_BTC_price) # изменяем форму массива для обратной нормализации предсказанных значений цен к их исходному диапазону

# В результае в "predicted_BTC_price" содержатся прогнозируемые значения цен на новых данных.

"""## Метрики эффективности работы модели
Для оценки эффективности работы модели мы можем использовать метрики, такие как:

- средняя квадратичная ошибка (MSE);
- корень из средней квадратичной ошибки (RMSE);
- стандартное отклонение реальных значений (STD);
- средняя абсолютная ошибка (MAE);
- среднее абсолютное значение процентной разности между прогнозируемыми значениями и фактическими значениями (MAPE);
- коэффициент детерминации (R2). 

"""

# RMSE показывает, насколько сильно прогнозы модели отличаются от реальных значений в среднем.
# вычислим RMSE
mse = np.mean(np.square(predicted_BTC_price - test_set))
mse

rmse = np.sqrt(mse)
rmse

# Вычислим стандартное отклонение (STD) реальных значений

y_test_std = np.std(test_set)
y_test_std

mae2 = np.mean(np.abs(predicted_BTC_price - test_set))
mae2

# MAE показывает, насколько близко прогнозы к реальным значениям в среднем
# вычислим MAE
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error

mae = mean_absolute_error(test_set, predicted_BTC_price)
mae

# MAPE показывает, насколько близко прогнозы к реальным значениям в процентном отношении
# вычислим MAPE
mape = mean_absolute_percentage_error(predicted_BTC_price, test_set)
mape

# R-squared показывает долю дисперсии в данных, которая объясняется моделью
# вычислим R-squared
from sklearn.metrics import r2_score

r2 = r2_score(predicted_BTC_price, test_set)
r2

# визуализация прогнозов и фактических значений на графике
plt.plot(test_set, label='фактические значения')
plt.plot(predicted_BTC_price, label='прогноз')
plt.legend()
plt.show()

"""Из полученных значений метрик можно сделать следующие выводы о точности модели:

STD = 1933.1, что означает, что реальные значения находятся в среднем в диапазоне +/- 1933 единиц от прогнозируемых значений.

RMSE = 2800.8, что означает, что средняя ошибка прогнозирования составляет около 2800 единиц валюты.

MAE = 628.8, что означает, что средняя абсолютная ошибка прогнозирования составляет около 628 единиц валюты. То есть, в среднем, модель ошибается на 628 единиц.

MAPE = 0.015, что означает, что средняя относительная ошибка прогнозирования составляет около 1.5%.

R-squared = 0.893, что говорит о том, что модель объясняет около 89% изменчивости цен на биткоин.

Исходя из этих результатов, можно сделать вывод, что модель имеет хорошую точность в прогнозировании цен на биткоин. Однако, следует учитывать, что точность модели не является абсолютной и зависит от многих факторов, таких как выборка данных, настройка гиперпараметров модели и т.д.

## Оценка результатов и выводы
"""

# Используем библиотеку Matplotlib для построения графика сравнения реальных и прогнозируемых значений цен

plt.figure(figsize=(25,15), dpi=80, facecolor='w', edgecolor='k') # задаем размеры и параметры фона и границ графика
ax = plt.gca() # получаем текущие оси графика и сохраняем их в переменной
plt.plot(test_set, color = 'red', label = 'Реальная цена BTC') # строим линию графика для реальных значений цен (красную)
plt.plot(predicted_BTC_price, color = 'blue', label = 'Прогнозируемая цена BTC') # строим линию графика для прогнозируемых значений цен (синюю)
plt.title('Прогнозируемая цена BTC', fontsize=40) # задаем заголовок графика
df_test = df_test.reset_index() 
x = df_test.index 
labels = df_test['Date']
plt.xticks(x, labels, rotation = 'vertical') # задаем метки оси x
for tick in ax.xaxis.get_major_ticks(): # задаем размеры шрифтов меток осей x и y
    tick.label1.set_fontsize(18) 
for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize(18)
plt.xlabel('Time', fontsize=40) # задаем метки оси x
plt.ylabel('BTC Price(USD)', fontsize=40) # задаем метки оси y
plt.legend(loc=2, prop={'size': 25}) # задаем легенду
plt.show() # отображаем график

"""# Оценка.
Понятно, что с помощью простой модели можно сделать разумный прогноз. Это работает до тех пор, пока окружающая среда стационарна (характер отношений между прошлыми и настоящими значениями остается стабильным с течением времени). Прогнозирование цен на активы — сложная задача. Произойдет резкое изменение цены из-за внезапных вмешательств, которые требуют разработки функций для достижения лучшего результата.
# Внедрение
Данная программа может быть использована в виде веб-приложения для трейдеров и инвесторов. Или в качестве чат-бота в Telegram.

"""